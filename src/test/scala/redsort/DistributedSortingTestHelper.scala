// This file was generated by Google Gemini 3 Pro, with some manual rewrites.

package redsort

import cats._
import cats.effect._
import java.nio.file._
import java.nio.file.attribute.BasicFileAttributes
import scala.sys.process._
import scala.jdk.CollectionConverters._
import java.io.IOException
import java.io.File
import redsort.Logging.fileLogger

object DistributedSortingTestHelper {

  /** Scaffolds a test environment for distributed sorting, generates data, runs the test body, and
    * validates the results using valsort.
    *
    * @param name
    *   The name of the test case (used for directory naming).
    * @param body
    *   A function that takes the base path string and returns the sequence of worker indices
    *   ordered by the key range they contain (Ascending).
    */
  def testSorting(
      name: String,
      numMachines: Int,
      numInputDirs: Int,
      numFilesPerInputDir: Int,
      recordsPerFile: Int
  )(body: String => IO[Seq[Int]]): IO[Unit] =
    fileLogger(name).use { logger =>
      for {
        baseDir <- IO(Paths.get("target", "test-sorting", name).toAbsolutePath)
        _ <- IO(prepare(baseDir, numMachines, numInputDirs, numFilesPerInputDir, recordsPerFile))
        machineOrder <- body(baseDir.toString)
        _ <- IO(validate(baseDir, machineOrder))
      } yield ()
    }

  private def prepare(
      baseDir: Path,
      numMachines: Int,
      numInputDirs: Int,
      numFilesPerInputDir: Int,
      recordsPerFile: Int
  ) = {
    // 0. Clean up previous run if exists
    if (Files.exists(baseDir)) {
      deleteRecursively(baseDir)
    }

    // 1. Scaffold directory structure
    val workers = (0 until numMachines).toSeq
    val inputDirs = (0 until numInputDirs).map(i => s"input$i")

    workers.foreach { w =>
      val workerPath = baseDir.resolve(s"worker$w")
      inputDirs.foreach { i =>
        Files.createDirectories(workerPath.resolve(i))
      }
    }
    Files.createDirectories(baseDir.resolve("master"))

    // 2. Run gensort
    // We maintain a running offset to ensure data is unique/contiguous across the whole set.
    var currentOffset = 0

    for {
      w <- workers
      i <- inputDirs
      fileIdx <- 0 until numFilesPerInputDir
    } {
      val outFile = baseDir.resolve(s"worker$w").resolve(i).resolve(s"input.$fileIdx")

      // gensort -b<offset> <count> <output_file>
      // -b specifies the starting record index to ensure correct global sorting potential
      val cmd = Seq("gensort", s"-b$currentOffset", recordsPerFile.toString, outFile.toString)

      val exitCode = cmd.!
      if (exitCode != 0) {
        throw new RuntimeException(s"gensort failed for $outFile with exit code $exitCode")
      }

      currentOffset += recordsPerFile
    }
  }

  private def validate(baseDir: Path, machineOrder: Seq[Int]) = {
    // 4. Run valsort
    // We must gather output files in the order of machines returned by the body.
    // Within a machine, we assume partition files are ordered by their partition number.

    val allOutputFiles = machineOrder.flatMap { workerIdx =>
      val outputDir = baseDir.resolve(s"worker$workerIdx").resolve("output")

      if (!Files.exists(outputDir)) {
        throw new RuntimeException(s"Output directory missing for worker$workerIdx: $outputDir")
      }

      // Get files, filter for "partition.<n>", sort them by order of <n>.
      val files = Files
        .list(outputDir)
        .iterator()
        .asScala
        .toSeq
        .filter(p => p.getFileName.toString.startsWith("partition."))
        .sortBy { p =>
          val fileName = p.getFileName.toString
          val index = fileName.substring("partition.".length, fileName.length).toInt
          index
        }

      if (files.isEmpty) {
        throw new RuntimeException(s"No partition files found in $outputDir")
      }

      files
    }

    if (allOutputFiles.isEmpty) {
      throw new RuntimeException("No output files found across any workers.")
    }

    // validate sort order
    // first create summary file for each partition files.
    val summaryFiles = allOutputFiles.map(p => {
      val fileName = p.getFileName.toString
      val index = fileName.substring("partition.".length, fileName.length).toInt
      val outFilePath = p.getParent().resolve(s"out$index.sum")

      val cmd = Seq("valsort", "-o", outFilePath.toString, p.toString)
      val exit = cmd.!

      if (exit != 0) {
        throw new RuntimeException(s"valsort summary generation failed for file ${p}.")
      }
    })

    // then concatenate all summary files to all.sum file
    val catCmd = Seq("cat") ++ allOutputFiles.map(_.toString)
    val summaryFile = baseDir.resolve("all.sum")
    val catExit = (catCmd #>> new File(summaryFile.toString)).!
    if (catExit != 0) {
      throw new Error(s"failed to concatenate summary files to ${summaryFile.toString}")
    }

    // finally validate sort
    val valsortCmd = Seq("valsort", "-s", summaryFile.toString)
    val valsortExit = valsortCmd.!

    if (valsortExit != 0) {
      throw new RuntimeException(
        s"valsort validation failed. Checked ${allOutputFiles.size} files."
      )
    }

    // 5. Check for stray files
    machineOrder.foreach { workerIdx =>
      val outputDir = baseDir.resolve(s"worker$workerIdx").resolve("output")

      val files = Files.list(outputDir).iterator().asScala.toSeq
      files.foreach { path =>
        val fileName = path.getFileName.toString
        val isDirectory = Files.isDirectory(path)
        val isPartitionFile = fileName.startsWith("partition.") && !isDirectory

        if (!isPartitionFile) {
          throw new RuntimeException(s"Found unexpected entry in output directory: $path")
        }
      }
    }
  }

  private def deleteRecursively(path: Path): Unit = {
    Files.walkFileTree(
      path,
      new SimpleFileVisitor[Path] {
        override def visitFile(file: Path, attrs: BasicFileAttributes): FileVisitResult = {
          Files.delete(file)
          FileVisitResult.CONTINUE
        }
        override def postVisitDirectory(dir: Path, exc: IOException): FileVisitResult = {
          Files.delete(dir)
          FileVisitResult.CONTINUE
        }
      }
    )
  }
}
